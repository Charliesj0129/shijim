Feature: 無鎖環形緩衝區寫入器 (Lock-Free Ring Buffer Writer)
  為了 以亞微秒級延遲將市場數據發布給策略層
  作為 Rust 核心開發者
  我要求 寫入器必須在不使用 Mutex 的情況下，安全地更新共享記憶體，並保證記憶體可見性 (Visibility)。

  # ---------------------------------------------------------------------------
  # 背景：Rust 端的記憶體映射
  # ---------------------------------------------------------------------------
  Background: 共享記憶體初始化
    Given 系統已映射了一塊共享記憶體區域 "shijim_market_data_l2"
    And 該區域被轉換為 Rust 結構體 `RingBuffer<Slot>`
    And `write_cursor` 初始化為 0
    And 緩衝區容量 (Capacity) 為 1024 (必須是 2 的冪次方)

  # ---------------------------------------------------------------------------
  # 場景 1: 單筆寫入與 Cursor 更新 (The Happy Path)
  # 驗證重點：寫入順序必須是 "先寫數據，後更新 Cursor"。
  # ---------------------------------------------------------------------------
  Scenario: 原子性發布單筆事件
    Given 我有一個 SBE 編碼完成的數據包 (48 bytes)
    And 當前 `write_cursor` 為 100
    When 寫入器執行 `publish(packet)`
    Then 寫入器應計算索引 `100 % 1024 = 100`
    And 數據應被寫入到 Slot[100] 的記憶體位置
    And 記憶體屏障 (Memory Barrier) 應確保數據寫入完成
    And `write_cursor` 應原子地增加至 101 (Ordering::Release)

  # ---------------------------------------------------------------------------
  # 場景 2: 環形繞行 (Wrap-Around)
  # 驗證重點：位運算優化與覆蓋舊數據。
  # ---------------------------------------------------------------------------
  Scenario: 跨越邊界寫入
    Given 當前 `write_cursor` 為 1023 (緩衝區最後一個槽位)
    When 寫入器發布一筆新數據
    Then 寫入器應計算索引 `1023 % 1024 = 1023` 並寫入
    And `write_cursor` 更新為 1024
    When 寫入器再發布一筆新數據 (Cursor = 1024)
    Then 寫入器應計算索引 `1024 % 1024 = 0` (回到開頭)
    And Slot[0] 的舊數據應被新數據覆蓋
    And `write_cursor` 更新為 1025

  # ---------------------------------------------------------------------------
  # 場景 3: 批次寫入優化 (Batch Commit)
  # 驗證重點：減少 Atomic 操作次數。如果一次來了 10 個封包，不要更新 10 次 Cursor。
  # 這是 HFT 的關鍵優化 (Amortized Cost)。
  # ---------------------------------------------------------------------------
  Scenario: 批次提交多筆事件
    Given 我從 UDP Socket 一次讀取了 5 個 SBE 封包 (Batch)
    And 當前 `write_cursor` 為 200
    When 寫入器呼叫 `reserve(5)` 獲取寫入權限
    Then 寫入器應獲得索引範圍 [200, 201, 202, 203, 204]
    When 寫入器依序將 5 個封包寫入對應槽位 (使用 Relaxed Store)
    And 呼叫 `commit(5)`
    Then `write_cursor` 應 **一次性** 從 200 更新為 205
    And 中間狀態 (如 201, 202) 不應對消費者可見 (取決於實作，但最終一致性必須保證)

  # ---------------------------------------------------------------------------
  # 場景 4: 避免偽共享 (False Sharing) 的佈局檢查
  # 驗證重點：這是一個靜態檢查測試 (Static Analysis Test)。
  # ---------------------------------------------------------------------------
  Scenario: 驗證 Cache Line Padding
    When 檢查 `RingBuffer` 結構體的記憶體佈局
    Then `write_cursor` 的地址與 `buffer` 的起始地址之間
    And 應至少相隔 64 Bytes (Cache Line Size)
    And `write_cursor` 自身應位於獨立的 Cache Line 上

  # ---------------------------------------------------------------------------
  # 場景 5: 飽和度監控 (Saturation Monitoring)
  # 驗證重點：雖然我們允許覆蓋，但如果寫入速度太快導致消費者完全讀不到，系統應發出警告。
  # ---------------------------------------------------------------------------
  Scenario: 監測消費者落後程度 (Lag)
    Given 系統有一個 "最慢消費者 Cursor" 的監控指標 (SlowestReaderCursor)
    And 當前 `write_cursor` 為 2000
    And `SlowestReaderCursor` 為 500 (落後 1500 > 容量 1024)
    When 寫入器執行狀態檢查
    Then 應觸發 "SlowConsumerAlert" 警報
    But 寫入器 **絕對不應** 減速或阻塞 (Block)
